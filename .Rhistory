#'
#'
build.taxon.metabolome <- function(
pc.directory = NULL,
taxid = c(),
get.properties = TRUE,
full.scored = TRUE,
aggregation.function = max,
threads = 8,
db.name = "custom.metabolome",
rcdk.desc = c(
"org.openscience.cdk.qsar.descriptors.molecular.XLogPDescriptor",
"org.openscience.cdk.qsar.descriptors.molecular.AcidicGroupCountDescriptor",
"org.openscience.cdk.qsar.descriptors.molecular.BasicGroupCountDescriptor",
"org.openscience.cdk.qsar.descriptors.molecular.TPSADescriptor"
),
pubchem.bio.object = NULL,
cid.lca.object = NULL,
taxid.hierarchy.object = NULL,
output.directory = NULL
) {
out.dir <- pc.directory
if(is.null(out.dir)) out.dir <- output.directory
if(is.null(pc.directory) & is.null(cid.lca.object)) {
stop("if you opt to note define the pc.directory, you must provide ALL of 'cid.lca.object', 'taxid.hierarchy.object', 'pubchem.bio.object' variables", '\n')
}
if(length(taxid) == 0) {
stop("please list at least one integer taxid, i.e. 'taxid = c(4071, 4081)'", '\n')
}
if(is.null(cid.lca.object)) {
load(paste0(pc.directory, "/cid.lca.Rdata"))
cid.lca <- cid.lca
} else {
cid.lca <- cid.lca.object
}
if(is.null(taxid.hierarchy.object)) {
load(paste0(pc.directory, "/taxid.hierarchy.Rdata"))
taxid.hierarchy <- taxid.hierarchy
} else {
taxid.hierarchy <- taxid.hierarchy.object
}
if(is.null(pubchem.bio.object)) {
load(paste0(pc.directory, "/pc.bio.Rdata"))
pc.bio <- pc.bio
} else {
pc.bio <- pubchem.bio.object
}
`%dopar%` <- foreach::`%dopar%`
out <- pc.bio
for(i in 1:length(taxid)) {
tax.match <- which(taxid.hierarchy == taxid[i], arr.ind = TRUE)
taxid.v <- as.vector(t(data.frame(taxid.hierarchy[tax.match[1,1],])))
metabolome <- unique(cid.lca$cid[cid.lca$lca %in% taxid.v])
keep <- which(metabolome %in% pc.bio$cid)
metabolome <- metabolome[keep]
## metabolome <- metabolome[keep]
## which(metabolome == 1548943)
if(full.scored) {
## get taxid hierarchy. store as vector.
## compare to each out taxid vector by lca
message(taxid[i], " ", length(keep), ' mapped metabolites')
taxid.row <- tax.match[1,1]
taxid.column <- as.integer(tax.match[1,2])
taxid.vector <- as.vector(unlist(taxid.hierarchy[taxid.row, 1:ncol(taxid.hierarchy)]))
## tmp is the index to the correct cid.lca row for each pubchem row
th.ind <- which(names(cid.lca) == "species"):ncol(cid.lca)
# th.ind <- th.ind[taxid.column:length(th.ind)]
tmp <- match(pc.bio$cid, cid.lca$cid)
message(" -- calculating similarities", '\n')
do.sim <- which(!is.na(tmp))
error <- NA
j <- 1
doParallel::registerDoParallel(cl <- parallel::makeCluster(threads))
results <- foreach::foreach(j = do.sim) %dopar% {
tryCatch(
#this is the chunk of code we want to run
{
mtch.col <- suppressWarnings((which(taxid.vector == cid.lca[tmp[j], th.ind])[1]) - taxid.column + 1)
mtch.col
#when it throws an error, the following block catches the error
}, error = function(msg){
stop("error on", j, '\n')
return(NA)
}
)
}
results <- unlist(results)
tax.lca.sim <- rep(NA, length(tmp))
tax.lca.sim[do.sim] <- results
tax.lca.sim <- round((max(tax.lca.sim, na.rm = TRUE) - tax.lca.sim)/length(th.ind), 4)
tax.lca.sim[pc.bio$cid %in% metabolome] <- 1
# tax.lca.sim <- rep(NA, length(tmp))
# tmp.ind <- 1:length(tmp)
# tmp.chunks <- split(tmp, ceiling(seq_along(tmp.ind)/100000))
# out.chunks <- as.list(rep(NA, length(tmp.chunks)))
# for(y in 1:length(tmp.chunks)) {
#   for(x in 1:length(tmp.chunks[[y]])) {
#     out.vec <- rep(NA, length(tmp.chunks))
#     if(!is.na(tmp.chunks[[y]][x])) {
#       out.vec[x] <- tryCatch(
#         #this is the chunk of code we want to run
#         {
#           mtch.col <- which(taxid.vector == cid.lca[tmp.chunks[[y]][x], th.ind])[1]
#           mtch.col
#           #when it throws an error, the following block catches the error
#         }, error = function(msg){
#           stop("error on", i, '\n')
#           return(NA)
#         }
#       )
#     }
#   }
# }
# do.sim <- which(!is.na(tmp))
# # do.sim <- do.sim[151600:length(do.sim)]
# do.sim.sim <- sapply((do.sim), FUN = function(x) {
# # tax.lca.sim <- sapply((800000:length(tmp)), FUN = function(x) {
#  message(x, ' ')
#     tryCatch(
#       #this is the chunk of code we want to run
#       {
#         mtch.col <- which(taxid.vector == cid.lca[tmp[x], th.ind])[1]
#         mtch.col
#         #when it throws an error, the following block catches the error
#       }, error = function(msg){
#         stop("error on", i, '\n')
#         return(NA)
#       }
#       )
# }
# )
# tax.lca.sim <- rep(NA, length(tmp))
# tax.lca.sim[do.sim] <- do.sim.sim
# tax.lca.sim <- (max(tax.lca.sim, na.rm = TRUE) - tax.lca.sim)/max(tax.lca.sim, na.rm = TRUE)
# tax.lca.sim[keep] <- 1
out[,paste0("taxonomy.lca.similarity.", taxid[i])] <- tax.lca.sim
doParallel::stopImplicitCluster()
}
}
if(!full.scored) {
message("keeping", length(keep), "metabolites", '\n')
out <- pc.bio[keep, ]
if(nrow(out) == 0) {
error("no metabolites found for taxid(s):", paste0(taxid, collapse = ", "))
}
} else {
## aggregate taxonomy.lca.similarity scores using assigned function
use.cols <- which(grepl("taxonomy.lca.similarity.", names(out)))
use.cols <- names(out)[use.cols]
suppressWarnings(agg.sim <- apply(out[, use.cols, drop = FALSE], 1, aggregation.function, na.rm = TRUE, simplify = TRUE))
agg.sim[is.infinite(agg.sim)] <- NA
# agg.sim <- agg.sim[unique(c(which(is.infinite(agg.sim)), which(is.na(agg.sim))))] <- NA
out[,paste0("taxonomy.lca.similarity.", "aggregate")] <- agg.sim
}
if(get.properties) {
message(" - calclulating rcdk properties",  format(Sys.time()), '\n')
cid.list <- as.list(out$cid)
sm.list <- as.list(out$smiles)
doParallel::registerDoParallel(cl <- parallel::makeCluster(threads))
base::on.exit(parallel::stopCluster(cl))
results <- foreach::foreach(i = 1:(length(cid.list))) %dopar% {
desc <- rcdk.desc
mol <- rcdk::parse.smiles(sm.list[[i]])
names(mol) <- cid.list[[i]]
if(is.null(mol)) {
descs <- rep(NA, length(desc))
} else {
descs <- rcdk::eval.desc(mol, desc)
}
descs
}
doParallel::stopImplicitCluster()
parallel::stopCluster(cl)
results.df <- do.call("rbind", results)
out <- out[order(out$cid),]
results.df <- results.df[order(as.numeric(row.names(results.df))),]
out <- data.frame(
out,
results.df
)
doParallel::stopImplicitCluster()
}
return(out)
doParallel::stopImplicitCluster()
if(!is.null(out.dir)) {
save(out, file = paste0(out.dir, "/", db.name, ".Rdata"))
}
}
data('cid.lca', package = "pubchem.bio")
data('pubchem.bio', package = "pubchem.bio")
data('taxid.hierarchy', package = "pubchem.bio")
my.taxon.db <- build.taxon.metabolome(
pubchem.bio.object = pubchem.bio,
cid.lca.object = cid.lca, taxid.hierarchy.object = taxid.hierarchy,
get.properties = FALSE, threads = 1, taxid = c(1))
build.taxon.metabolome <- function(
pc.directory = NULL,
taxid = c(),
get.properties = TRUE,
full.scored = TRUE,
aggregation.function = max,
threads = 8,
db.name = "custom.metabolome",
rcdk.desc = c(
"org.openscience.cdk.qsar.descriptors.molecular.XLogPDescriptor",
"org.openscience.cdk.qsar.descriptors.molecular.AcidicGroupCountDescriptor",
"org.openscience.cdk.qsar.descriptors.molecular.BasicGroupCountDescriptor",
"org.openscience.cdk.qsar.descriptors.molecular.TPSADescriptor"
),
pubchem.bio.object = NULL,
cid.lca.object = NULL,
taxid.hierarchy.object = NULL,
output.directory = NULL
) {
out.dir <- pc.directory
if(is.null(out.dir)) out.dir <- output.directory
if(is.null(pc.directory) & is.null(cid.lca.object)) {
stop("if you opt to note define the pc.directory, you must provide ALL of 'cid.lca.object', 'taxid.hierarchy.object', 'pubchem.bio.object' variables", '\n')
}
if(length(taxid) == 0) {
stop("please list at least one integer taxid, i.e. 'taxid = c(4071, 4081)'", '\n')
}
if(is.null(cid.lca.object)) {
load(paste0(pc.directory, "/cid.lca.Rdata"))
cid.lca <- cid.lca
} else {
cid.lca <- cid.lca.object
}
if(is.null(taxid.hierarchy.object)) {
load(paste0(pc.directory, "/taxid.hierarchy.Rdata"))
taxid.hierarchy <- taxid.hierarchy
} else {
taxid.hierarchy <- taxid.hierarchy.object
}
if(is.null(pubchem.bio.object)) {
load(paste0(pc.directory, "/pc.bio.Rdata"))
pc.bio <- pc.bio
} else {
pc.bio <- pubchem.bio.object
}
`%dopar%` <- foreach::`%dopar%`
out <- pc.bio
for(i in 1:length(taxid)) {
tax.match <- which(taxid.hierarchy == taxid[i], arr.ind = TRUE)
taxid.v <- as.vector(t(data.frame(taxid.hierarchy[tax.match[1,1],])))
metabolome <- unique(cid.lca$cid[cid.lca$lca %in% taxid.v])
keep <- which(metabolome %in% pc.bio$cid)
metabolome <- metabolome[keep]
## metabolome <- metabolome[keep]
## which(metabolome == 1548943)
if(full.scored) {
## get taxid hierarchy. store as vector.
## compare to each out taxid vector by lca
message(taxid[i], " ", length(keep), ' mapped metabolites')
taxid.row <- tax.match[1,1]
taxid.column <- as.integer(tax.match[1,2])
taxid.vector <- as.vector(unlist(taxid.hierarchy[taxid.row, 1:ncol(taxid.hierarchy)]))
## tmp is the index to the correct cid.lca row for each pubchem row
th.ind <- which(names(cid.lca) == "species"):ncol(cid.lca)
# th.ind <- th.ind[taxid.column:length(th.ind)]
tmp <- match(pc.bio$cid, cid.lca$cid)
message(" -- calculating similarities", '\n')
do.sim <- which(!is.na(tmp))
error <- NA
j <- 1
doParallel::registerDoParallel(cl <- parallel::makeCluster(threads))
results <- foreach::foreach(j = do.sim) %dopar% {
tryCatch(
#this is the chunk of code we want to run
{
mtch.col <- suppressWarnings((which(taxid.vector == cid.lca[tmp[j], th.ind])[1]) - taxid.column + 1)
mtch.col
#when it throws an error, the following block catches the error
}, error = function(msg){
stop("error on", j, '\n')
return(NA)
}
)
}
results <- unlist(results)
tax.lca.sim <- rep(NA, length(tmp))
tax.lca.sim[do.sim] <- results
tax.lca.sim <- round((max(tax.lca.sim, na.rm = TRUE) - tax.lca.sim)/length(th.ind), 4)
tax.lca.sim[pc.bio$cid %in% metabolome] <- 1
# tax.lca.sim <- rep(NA, length(tmp))
# tmp.ind <- 1:length(tmp)
# tmp.chunks <- split(tmp, ceiling(seq_along(tmp.ind)/100000))
# out.chunks <- as.list(rep(NA, length(tmp.chunks)))
# for(y in 1:length(tmp.chunks)) {
#   for(x in 1:length(tmp.chunks[[y]])) {
#     out.vec <- rep(NA, length(tmp.chunks))
#     if(!is.na(tmp.chunks[[y]][x])) {
#       out.vec[x] <- tryCatch(
#         #this is the chunk of code we want to run
#         {
#           mtch.col <- which(taxid.vector == cid.lca[tmp.chunks[[y]][x], th.ind])[1]
#           mtch.col
#           #when it throws an error, the following block catches the error
#         }, error = function(msg){
#           stop("error on", i, '\n')
#           return(NA)
#         }
#       )
#     }
#   }
# }
# do.sim <- which(!is.na(tmp))
# # do.sim <- do.sim[151600:length(do.sim)]
# do.sim.sim <- sapply((do.sim), FUN = function(x) {
# # tax.lca.sim <- sapply((800000:length(tmp)), FUN = function(x) {
#  message(x, ' ')
#     tryCatch(
#       #this is the chunk of code we want to run
#       {
#         mtch.col <- which(taxid.vector == cid.lca[tmp[x], th.ind])[1]
#         mtch.col
#         #when it throws an error, the following block catches the error
#       }, error = function(msg){
#         stop("error on", i, '\n')
#         return(NA)
#       }
#       )
# }
# )
# tax.lca.sim <- rep(NA, length(tmp))
# tax.lca.sim[do.sim] <- do.sim.sim
# tax.lca.sim <- (max(tax.lca.sim, na.rm = TRUE) - tax.lca.sim)/max(tax.lca.sim, na.rm = TRUE)
# tax.lca.sim[keep] <- 1
out[,paste0("taxonomy.lca.similarity.", taxid[i])] <- tax.lca.sim
doParallel::stopImplicitCluster()
}
}
if(!full.scored) {
message("keeping", length(keep), "metabolites", '\n')
out <- pc.bio[keep, ]
if(nrow(out) == 0) {
error("no metabolites found for taxid(s):", paste0(taxid, collapse = ", "))
}
} else {
## aggregate taxonomy.lca.similarity scores using assigned function
use.cols <- which(grepl("taxonomy.lca.similarity.", names(out)))
..use.cols <- use.cols
suppressWarnings(agg.sim <- apply(out[, ..use.cols, drop = FALSE], 1, aggregation.function, na.rm = TRUE, simplify = TRUE))
agg.sim[is.infinite(agg.sim)] <- NA
# agg.sim <- agg.sim[unique(c(which(is.infinite(agg.sim)), which(is.na(agg.sim))))] <- NA
out[,paste0("taxonomy.lca.similarity.", "aggregate")] <- agg.sim
}
if(get.properties) {
message(" - calclulating rcdk properties",  format(Sys.time()), '\n')
cid.list <- as.list(out$cid)
sm.list <- as.list(out$smiles)
doParallel::registerDoParallel(cl <- parallel::makeCluster(threads))
base::on.exit(parallel::stopCluster(cl))
results <- foreach::foreach(i = 1:(length(cid.list))) %dopar% {
desc <- rcdk.desc
mol <- rcdk::parse.smiles(sm.list[[i]])
names(mol) <- cid.list[[i]]
if(is.null(mol)) {
descs <- rep(NA, length(desc))
} else {
descs <- rcdk::eval.desc(mol, desc)
}
descs
}
doParallel::stopImplicitCluster()
parallel::stopCluster(cl)
results.df <- do.call("rbind", results)
out <- out[order(out$cid),]
results.df <- results.df[order(as.numeric(row.names(results.df))),]
out <- data.frame(
out,
results.df
)
doParallel::stopImplicitCluster()
}
return(out)
doParallel::stopImplicitCluster()
if(!is.null(out.dir)) {
save(out, file = paste0(out.dir, "/", db.name, ".Rdata"))
}
}
my.taxon.db <- build.taxon.metabolome(
pubchem.bio.object = pubchem.bio,
cid.lca.object = cid.lca, taxid.hierarchy.object = taxid.hierarchy,
get.properties = FALSE, threads = 1, taxid = c(1))
head(my.taxon.db)
package.path <- "//csunts.acns.colostate.edu/arc/cbroeckl/Documents/GitHub/"
package.name <- "pubchem.bio"
package.dir <- paste0(package.path, package.name)
roxygen2::roxygenise(package.dir)
devtools::check(package.dir)
roxygen2::roxygenise(package.dir)
roxygen2::roxygenise(package.dir)
roxygen2::roxygenise(package.dir)
roxygen2::roxygenise(package.dir)
devtools::check(package.dir)
data('cid.sid', package = "pubchem.bio")
data('cid.pwid', package = "pubchem.bio")
data('cid.parent', package = "pubchem.bio")
data('cid.taxid', package = "pubchem.bio")
data('cid.formula', package = "pubchem.bio")
data('cid.smiles', package = "pubchem.bio")
data('cid.inchikey', package = "pubchem.bio")
data('cid.monoisotopic.mass', package = "pubchem.bio")
data('cid.title', package = "pubchem.bio")
data('cid.cas', package = "pubchem.bio")
data('cid.pmid.ct', package = "pubchem.bio")
pc.bio.out <- build.pubchem.bio(use.pathways = FALSE, use.parent.cid = FALSE,
get.properties = FALSE, threads = 1,
cid.sid.object = cid.sid, cid.pwid.object = cid.pwid,
cid.parent.object = cid.parent, cid.taxid.object = cid.taxid,
cid.formula.object = cid.formula, cid.smiles.object = cid.smiles,
cid.inchikey.object = cid.inchikey,
cid.monoisotopic.mass.object = cid.monoisotopic.mass,
cid.title.object = cid.title, cid.cas.object = cid.cas,
cid.pmid.ct.object = cid.pmid.ct)
head(pc.bio.out)
if (!inherits(future::plan(), "sequential")) future::plan(sequential)
roxygen2::roxygenise(package.dir)
devtools::check(package.dir)
unregister <- function() {
env <- foreach:::.foreachGlobals
rm(list=ls(name=env), pos=env)
}
unregister()
roxygen2::roxygenise(package.dir)
devtools::check(package.dir)
package.path <- "//csunts.acns.colostate.edu/arc/cbroeckl/Documents/GitHub/"
package.name <- "pubchem.bio"
package.dir <- paste0(package.path, package.name)
data('cid.taxid', package = "pubchem.bio")
data('taxid.hierarchy', package = "pubchem.bio")
cid.lca.out <- build.cid.lca(tax.sources =  "LOTUS - the natural products occurrence database",
use.pathways = FALSE,
threads = 1, cid.taxid.object = cid.taxid,
taxid.hierarchy.object = taxid.hierarchy)
devtools::install(package.dir, dependencies = FALSE, force = TRUE)
data('cid.taxid', package = "pubchem.bio")
data('taxid.hierarchy', package = "pubchem.bio")
cid.lca.out <- build.cid.lca(tax.sources =  "LOTUS - the natural products occurrence database",
use.pathways = FALSE,
threads = 1, cid.taxid.object = cid.taxid,
taxid.hierarchy.object = taxid.hierarchy)
data('cid.taxid', package = "pubchem.bio")
data('taxid.hierarchy', package = "pubchem.bio")
cid.lca.out <- pubchem.bio::build.cid.lca(tax.sources =  "LOTUS - the natural products occurrence database",
use.pathways = FALSE,
threads = 1, cid.taxid.object = cid.taxid,
taxid.hierarchy.object = taxid.hierarchy)
head(cid.lca.out)
data('cid.sid', package = "pubchem.bio")
data('cid.pwid', package = "pubchem.bio")
data('cid.parent', package = "pubchem.bio")
data('cid.taxid', package = "pubchem.bio")
data('cid.formula', package = "pubchem.bio")
data('cid.smiles', package = "pubchem.bio")
data('cid.inchikey', package = "pubchem.bio")
data('cid.monoisotopic.mass', package = "pubchem.bio")
data('cid.title', package = "pubchem.bio")
data('cid.cas', package = "pubchem.bio")
data('cid.pmid.ct', package = "pubchem.bio")
pc.bio.out <- pubchem.bio::build.pubchem.bio(use.pathways = FALSE, use.parent.cid = FALSE,
get.properties = FALSE, threads = 1,
cid.sid.object = cid.sid, cid.pwid.object = cid.pwid,
cid.parent.object = cid.parent, cid.taxid.object = cid.taxid,
cid.formula.object = cid.formula, cid.smiles.object = cid.smiles,
cid.inchikey.object = cid.inchikey,
cid.monoisotopic.mass.object = cid.monoisotopic.mass,
cid.title.object = cid.title, cid.cas.object = cid.cas,
cid.pmid.ct.object = cid.pmid.ct)
head(pc.bio.out)
data('cid.lca', package = "pubchem.bio")
data('pubchem.bio', package = "pubchem.bio")
data('taxid.hierarchy', package = "pubchem.bio")
my.taxon.db <- pubchem.bio::build.taxon.metabolome(
pubchem.bio.object = pubchem.bio,
cid.lca.object = cid.lca, taxid.hierarchy.object = taxid.hierarchy,
get.properties = FALSE, threads = 1, taxid = c(1))
head(my.taxon.db)
roxygen2::roxygenise(package.dir)
devtools::install(package.dir, dependencies = FALSE, force = TRUE)
detach('package:pubchem.bio')
devtools::check(package.dir)
??`:::`
foreach:::.foreachGlobals
nchar("tax.sources =  "LOTUS - the natural products occurrence database",")
nchar('tax.sources =  "LOTUS - the natural products occurrence database",')
detach('package:pubchem.bio')
roxygen2::roxygenise(package.dir)
detach('package:pubchem.bio')
remotes::install_local(package.dir, dependencies = FALSE, force = TRUE)
detach('package:pubchem.bio')
devtools::install(package.dir, dependencies = FALSE, force = TRUE)
devtools::check(package.dir)
roxygen2::roxygenise(package.dir)
devtools::install(package.dir, dependencies = FALSE, force = TRUE)
library(pubchem.bio)
detach('package:pubchem.bio')
devtools::check(package.dir)
devtools::check_win_release(package.dir, email = 'cbroeckl@colostate.edu')
## push to CRAN
setwd(package.dir)
package.path <- "//csunts.acns.colostate.edu/arc/cbroeckl/Documents/GitHub/"
package.name <- "pubchem.bio"
package.dir <- paste0(package.path, package.name)
usethis::use_cran_comments()
usethis::use_news_md()
devtools::release(package.dir, check = FALSE)
roxygen2::roxygenise(package.dir)
roxygen2::roxygenise(package.dir)
devtools::install(package.dir, dependencies = FALSE, force = TRUE)
devtools::check(package.dir)
