server <- function(input, output, session) {
# Reactive expression to filter data
filtered_data <- reactive({
req(input$monoisotopic.mass, input$ppm.tolerance)
center <- suppressWarnings(as.numeric(input$monoisotopic.mass))
range <- suppressWarnings(as.numeric(input$monoisotopic.mass) * as.numeric(input$ppm.tolerance) / 1000000)
pc.bio$adduct.mz <- switch(input$operation,
"none" = pc.bio$monoisotopic.mass + 0,
"addH" = pc.bio$monoisotopic.mass + 1.007276,
"addNa" = pc.bio$monoisotopic.mass + 22.989218,
"addK" = pc.bio$monoisotopic.mass + 38.963158,
"addNH4" = pc.bio$monoisotopic.mass + 18.033823,
"addHminusH20" = pc.bio$monoisotopic.mass + 1.007276 - 18.010564683,
"mplusRadical" = pc.bio$monoisotopic.mass - 0.00054857,
"minusH" = pc.bio$monoisotopic.mass - 1.007276,
"minus2HplusNa"  = pc.bio$monoisotopic.mass-(2*1.007276) + 22.989218,
"minus2HplusK" = pc.bio$monoisotopic.mass-(2*1.007276) + 38.963158,
"addFormate" = pc.bio$monoisotopic.mass + 44.998201,
"addAcetate" = pc.bio$monoisotopic.mass + 59.013851,
"addCl" = pc.bio$monoisotopic.mass + 34.969402,
"mminusRadical" = pc.bio$monoisotopic.mass + 0.00054857,
df$Value)
if (is.na(center) || is.na(range)) {
return(data.frame(Error = "Please enter valid numeric values"))
}
lower <- center - range
upper <- center + range
pc.bio$ppm.error <- round(1000000*((center - pc.bio$adduct.mz)/center),2)
if(input$use_absolute_error) pc.bio$ppm.error<- abs(pc.bio$ppm.error)
if (!input$show_all) {
use.cols <- c("cid", "name", "formula", "monoisotopic.mass", "adduct.mz", "ppm.error", "smiles")
} else {
use.cols <- c("cid", "name", "formula", "monoisotopic.mass", "adduct.mz", "ppm.error", "smiles")
use.cols <- c(use.cols, names(pc.bio)[!(names(pc.bio) %in% use.cols)])
}
display.pc.bio <- pc.bio[which(pc.bio$adduct.mz >= lower & pc.bio$adduct.mz <= upper), use.cols]
display.pc.bio
# subset(pc.bio, adduct.mz >= lower & adduct.mz <= upper)
})
# Render filtered table with server-side processing
output$filtered_table <- renderDT({
datatable(
filtered_data(),
rownames = FALSE,
options = list(
pageLength = 10,
scrollX = TRUE,
server = TRUE
),selection = c("single")
)
}, server = TRUE)
output$ms1spectrum <- renderPlotly({
selected <- input$filtered_table_rows_selected
if (length(selected) & input$show_isotopes) {
row <- filtered_data()[selected, ]
formula <- row$formula
# smiles <- as.character(row$smiles)
# sdf <- smiles2sdf(smiles)
# mol <- parse.smiles(smiles)[[1]]
formula <- switch(input$operation,
"none" = formula,
"addH" = addElements(formula, "H"),
"addNa" = addElements(formula, "Na"),
"addK" = addElements(formula, "K"),
"addNH4" = addElements(formula, "NH4"),
"addHminusH20" = subtractElements(formula, "OH"),
"mplusRadical" = formula,
"minusH" = subtractElements(formula, "H"),
"minus2HplusNa"  = addElements(subtractElements(formula, "H2"), Na),
"minus2HplusK" = addElements(subtractElements(formula, "H2"), K),
"addFormate" = addElements(formula, "CHO2"),
"addAcetate" = addElements(formula, "C2H3O2"),
"addCl" = addElements(formula, "Cl"),
"mminusRadical" = formula,
df$Value)
z <- switch(input$operation,
"none" = 0,
"addH" = 1,
"addNa" = 1,
"addK" = 1,
"addNH4" = 1,
"addHminusH20" = 1,
"mplusRadical" = 1,
"minusH" = -1,
"minus2HplusNa"  = -1,
"minus2HplusK" = -1,
"addFormate" = -1,
"addAcetate" = -1,
"addCl" = -1,
"mminusRadical" = -1,
df$Value)
# z <- -1
iso.pattern <- enviPat::isopattern(isotopes, chemforms = formula, charge = z)
# head(iso.pattern)[[1]]
iso.profile <- data.frame(enviPat::envelope(iso.pattern, resolution = input$resolving.power)[[1]], check.names = TRUE)
# head(iso.profile)
## add ion formula adjustment based on adduct type selected
## use envipat to get isotope envelope and centroids
## then plot that.  need to set resolving power option.
plot_ly(iso.profile, x = ~m.z, y = ~abundance,  type = 'scatter', mode = 'lines', name = formula) %>%
layout(title = formula)
} else {
plot_ly() %>% layout(title = "Select a row to plot the isotopic envelope")
}
})
output$structure <- renderPlotly({
selected <- input$filtered_table_rows_selected
if (length(selected) & input$show_structure) {
row <- filtered_data()[selected, ]
formula <- row$formula
smiles <- as.character(row$smiles)[1]
str <- ChemmineR::smiles2sdf(smiles)[[1]]
elems <- c(
"C" = "black",
"N" = "blue",
"O" = 'red',
"F" = 'palegreen',
"Cl" = "green",
"Br" = "darkred",
"I" = "darkviolet",
"P" = "orange",
"S" = "yellow",
"B" = "beige",
"He" = "cyan",
"Ne" = "cyan",
"Ar" = "cyan",
"Kr" = "cyan",
"Xe" = "cyan",
"Rn" = "cyan",
"Li" = "violet",
"Na" = "violet",
"K" = "violet",
"Rb" = "violet",
"Cs" = "violet",
"Fr" = "violet",
"Be" = "darkgreen",
"Mg" = "darkgreen",
"Ca" = "darkgreen",
"Sr" = "darkgreen",
"Ba" = "darkgreen",
"Ra" = "darkgreen",
"Ti" = "gray",
"Fe" = 'darkorange'
)
# str@atomblock
# str@bondblock
df <- data.frame(
atomId = sapply(1:nrow(str@atomblock), FUN = function(x) unlist(strsplit(rownames(str@atomblock)[x], "_"))[2]),
element = sapply(1:nrow(str@atomblock), FUN = function(x) unlist(strsplit(rownames(str@atomblock)[x], "_"))[1]),
xCord = str@atomblock[,1],
yCord = str@atomblock[,2]
)
df$color <- elems[match(df$element, names(elems))]
conn <- data.frame(
atom1 = str@bondblock[,1],
atom2 = str@bondblock[,2],
order = str@bondblock[,3]
)
tmp <- plot_ly(x = df$xCord, y = df$yCord, type="scatter", showlegend = FALSE,
mode="none", color = df$element, hoverinfo = "text", size = 100,
text = paste('AtomId: ', df$atomId, "\nElement: ", df$element)) %>%
layout(xaxis = list(zeroline = F,
showgrid = F,
showticklabels = F),
yaxis = list(zeroline = F,
showgrid = F,
showticklabels = F)
)
x.range <- max(df[,3]) - min(df[,3])
y.range <- max(df[,4]) - min (df[,4])
for(i in 1:nrow(conn)) {
for(j in 1:conn[i,'order']) {
offset <- c(0, 0.04, -0.04)
x.st <- df[which(df[,1] == as.character(conn[i,1])),3]
x.end <- df[which(df[,1] == as.character(conn[i,2])),3]
y.st <- df[which(df[,1] == as.character(conn[i,1])),4]
y.end <- df[which(df[,1] == as.character(conn[i,2])),4]
slope <- (max(y.st, y.end) - min(y.st, y.end))/(max(x.st, x.end) - min(x.st, x.end))
y.diff <- y.end - y.st
x.diff <- x.end - x.st
x.st <-  x.st  - y.diff*offset[j] + 0.02*y.range*offset[j]
x.end <- x.end - y.diff*offset[j] + 0.02*y.range*offset[j]
y.st <-  y.st  + x.diff*offset[j] + 0.02*x.range*offset[j]
y.end <- y.end + x.diff*offset[j] + 0.02*x.range*offset[j]
tmp <- tmp %>%
add_segments(x = x.st, xend = x.end,
y = y.st, yend = y.end,
showlegend = FALSE, line = list(width = 1, color = "gray"))
}
}
tmp <- suppressWarnings(tmp %>% add_trace(x = df$xCord, y = df$yCord, type="scatter",  showlegend = TRUE,
text = df[,2], textfont = list(size = max(10, 70/x.range)),
marker = list(
color = 'white', # Set marker color to white for the background
size = max(11, 90/x.range),       # Adjust marker size to encompass the text
symbol = 'square' # Use a square symbol for a clear background
),
mode="text", color = I(df$color), fill = 'white', hoverinfo = "text",
text = paste("\nElement: ", df$element)))
tmp
} else {
str <- ChemmineR::smiles2sdf("CCC")[[1]]
out <- plot(str, verbose = FALSE)
out
}
})
# output$structure <- renderPlot({
#   height = "100%"
#   selected <- input$filtered_table_rows_selected
#   if (length(selected)) {
#     row <- filtered_data()[selected, ]
#     formula <- row$formula
#     smiles <- as.character(row$smiles)
#     str <- ChemmineR::smiles2sdf(smiles)[[1]]
#     ChemmineR::plotStruc(str)
#
#   } else {
#     plot(0,0)
#   }
# })
}
# Run the app
shinyApp(ui, server)
library(shiny)
library(DT)
library(ggplot2)
library(plotly)
library(enviPat)
library(ChemmineR)
# load data
load("R:/RSTOR-PMF/Software/pubchem.bio/pc.bio.Rdata")
pc.bio$TopoPSA <- round(pc.bio$TopoPSA, 2)
pc.bio$XLogP <- round(pc.bio$XLogP, 2)
data(isotopes)
# Define UI
ui <- fluidPage(
titlePanel("Filter pubchem.bio database by monoisotopic mass"),
sidebarLayout(
sidebarPanel(
numericInput("monoisotopic.mass", "Enter neutral or ion mass value:", value = 194.0803),
numericInput("ppm.tolerance", "Enter m/z ppm tolerance:", value = 5),
selectInput("operation", "Select adduct type:",
choices = c("Neutral mass" = "none",
"[M+H]+" = "addH",
"[M+Na]+" = "addNa",
"[M+K]+" = "addK",
"[M+NH4]+" = "addNH4",
"[M+H-H2O]+" = "addHminusH20",
"[M]+" = "mplusRadical",
"[M-H]-" = "minusH",
"[M-2H+Na]-" = "minus2HplusNa",
"[M-2H+K]-" = "minus2HplusK",
"[M+Formate]-" = "addFormate",
"[M+Acetate]-" = "addAcetate",
"[M+Cl]-" = "addCl",
"[M]-" = "mminusRadical"
)),
checkboxInput("show_all", "Show all columns", value = FALSE),
checkboxInput("show_isotopes", "Show predicted isotope envelope", value = TRUE),
checkboxInput("show_structure", "Show structure", value = TRUE),
checkboxInput("use_absolute_error", "Use absolute PPM error", value = TRUE),
numericInput("resolving.power", "Enter instrument resolution:", value = 80000),
helpText("Filters metabolites where measured mass as adduct selected is within monoisotopic.mass Â± ppm error range."),
width = 2
),
mainPanel(
fluidRow(
column(12,
DTOutput("filtered_table")
)
),
fluidRow(
column(6, div(style =  "Bottomleft"),
plotlyOutput("ms1spectrum", height = "60%")
),
column(6, div(style =  "Bottomright"),
plotlyOutput("structure", height = "60%")
)
), height = "100%"
)
)
)
# Define Server
server <- function(input, output, session) {
# Reactive expression to filter data
filtered_data <- reactive({
req(input$monoisotopic.mass, input$ppm.tolerance)
center <- suppressWarnings(as.numeric(input$monoisotopic.mass))
range <- suppressWarnings(as.numeric(input$monoisotopic.mass) * as.numeric(input$ppm.tolerance) / 1000000)
pc.bio$adduct.mz <- switch(input$operation,
"none" = pc.bio$monoisotopic.mass + 0,
"addH" = pc.bio$monoisotopic.mass + 1.007276,
"addNa" = pc.bio$monoisotopic.mass + 22.989218,
"addK" = pc.bio$monoisotopic.mass + 38.963158,
"addNH4" = pc.bio$monoisotopic.mass + 18.033823,
"addHminusH20" = pc.bio$monoisotopic.mass + 1.007276 - 18.010564683,
"mplusRadical" = pc.bio$monoisotopic.mass - 0.00054857,
"minusH" = pc.bio$monoisotopic.mass - 1.007276,
"minus2HplusNa"  = pc.bio$monoisotopic.mass-(2*1.007276) + 22.989218,
"minus2HplusK" = pc.bio$monoisotopic.mass-(2*1.007276) + 38.963158,
"addFormate" = pc.bio$monoisotopic.mass + 44.998201,
"addAcetate" = pc.bio$monoisotopic.mass + 59.013851,
"addCl" = pc.bio$monoisotopic.mass + 34.969402,
"mminusRadical" = pc.bio$monoisotopic.mass + 0.00054857,
df$Value)
if (is.na(center) || is.na(range)) {
return(data.frame(Error = "Please enter valid numeric values"))
}
lower <- center - range
upper <- center + range
pc.bio$ppm.error <- round(1000000*((center - pc.bio$adduct.mz)/center),2)
if(input$use_absolute_error) pc.bio$ppm.error<- abs(pc.bio$ppm.error)
if (!input$show_all) {
use.cols <- c("cid", "name", "formula", "monoisotopic.mass", "adduct.mz", "ppm.error", "smiles")
} else {
use.cols <- c("cid", "name", "formula", "monoisotopic.mass", "adduct.mz", "ppm.error", "smiles")
use.cols <- c(use.cols, names(pc.bio)[!(names(pc.bio) %in% use.cols)])
}
display.pc.bio <- pc.bio[which(pc.bio$adduct.mz >= lower & pc.bio$adduct.mz <= upper), use.cols]
display.pc.bio
# subset(pc.bio, adduct.mz >= lower & adduct.mz <= upper)
})
# Render filtered table with server-side processing
output$filtered_table <- renderDT({
datatable(
filtered_data(),
rownames = FALSE,
options = list(
pageLength = 10,
scrollX = TRUE,
server = TRUE
),selection = c("single")
)
}, server = TRUE)
output$ms1spectrum <- renderPlotly({
selected <- input$filtered_table_rows_selected
if (length(selected) & input$show_isotopes) {
row <- filtered_data()[selected, ]
formula <- row$formula
# smiles <- as.character(row$smiles)
# sdf <- smiles2sdf(smiles)
# mol <- parse.smiles(smiles)[[1]]
formula <- switch(input$operation,
"none" = formula,
"addH" = addElements(formula, "H"),
"addNa" = addElements(formula, "Na"),
"addK" = addElements(formula, "K"),
"addNH4" = addElements(formula, "NH4"),
"addHminusH20" = subtractElements(formula, "OH"),
"mplusRadical" = formula,
"minusH" = subtractElements(formula, "H"),
"minus2HplusNa"  = addElements(subtractElements(formula, "H2"), Na),
"minus2HplusK" = addElements(subtractElements(formula, "H2"), K),
"addFormate" = addElements(formula, "CHO2"),
"addAcetate" = addElements(formula, "C2H3O2"),
"addCl" = addElements(formula, "Cl"),
"mminusRadical" = formula,
df$Value)
z <- switch(input$operation,
"none" = 0,
"addH" = 1,
"addNa" = 1,
"addK" = 1,
"addNH4" = 1,
"addHminusH20" = 1,
"mplusRadical" = 1,
"minusH" = -1,
"minus2HplusNa"  = -1,
"minus2HplusK" = -1,
"addFormate" = -1,
"addAcetate" = -1,
"addCl" = -1,
"mminusRadical" = -1,
df$Value)
# z <- -1
iso.pattern <- enviPat::isopattern(isotopes, chemforms = formula, charge = z)
# head(iso.pattern)[[1]]
iso.profile <- data.frame(enviPat::envelope(iso.pattern, resolution = input$resolving.power)[[1]], check.names = TRUE)
# head(iso.profile)
## add ion formula adjustment based on adduct type selected
## use envipat to get isotope envelope and centroids
## then plot that.  need to set resolving power option.
plot_ly(iso.profile, x = ~m.z, y = ~abundance,  type = 'scatter', mode = 'lines', name = formula) %>%
layout(title = formula)
} else {
plot_ly() %>% layout(title = "Select a row to plot the isotopic envelope")
}
})
output$structure <- renderPlotly({
selected <- input$filtered_table_rows_selected
if (length(selected) & input$show_structure) {
row <- filtered_data()[selected, ]
formula <- row$formula
smiles <- as.character(row$smiles)[1]
str <- ChemmineR::smiles2sdf(smiles)[[1]]
elems <- c(
"C" = "black",
"N" = "blue",
"O" = 'red',
"F" = 'palegreen',
"Cl" = "green",
"Br" = "darkred",
"I" = "darkviolet",
"P" = "orange",
"S" = "yellow",
"B" = "beige",
"He" = "cyan",
"Ne" = "cyan",
"Ar" = "cyan",
"Kr" = "cyan",
"Xe" = "cyan",
"Rn" = "cyan",
"Li" = "violet",
"Na" = "violet",
"K" = "violet",
"Rb" = "violet",
"Cs" = "violet",
"Fr" = "violet",
"Be" = "darkgreen",
"Mg" = "darkgreen",
"Ca" = "darkgreen",
"Sr" = "darkgreen",
"Ba" = "darkgreen",
"Ra" = "darkgreen",
"Ti" = "gray",
"Fe" = 'darkorange'
)
# str@atomblock
# str@bondblock
df <- data.frame(
atomId = sapply(1:nrow(str@atomblock), FUN = function(x) unlist(strsplit(rownames(str@atomblock)[x], "_"))[2]),
element = sapply(1:nrow(str@atomblock), FUN = function(x) unlist(strsplit(rownames(str@atomblock)[x], "_"))[1]),
xCord = str@atomblock[,1],
yCord = str@atomblock[,2]
)
df$color <- elems[match(df$element, names(elems))]
conn <- data.frame(
atom1 = str@bondblock[,1],
atom2 = str@bondblock[,2],
order = str@bondblock[,3]
)
tmp <- plot_ly(x = df$xCord, y = df$yCord, type="scatter", showlegend = FALSE,
mode="none", color = df$element, hoverinfo = "text", size = 100,
text = paste('AtomId: ', df$atomId, "\nElement: ", df$element)) %>%
layout(xaxis = list(zeroline = F,
showgrid = F,
showticklabels = F),
yaxis = list(zeroline = F,
showgrid = F,
showticklabels = F)
)
x.range <- max(df[,3]) - min(df[,3])
y.range <- max(df[,4]) - min (df[,4])
for(i in 1:nrow(conn)) {
for(j in 1:conn[i,'order']) {
offset <- c(0, 0.04, -0.04)
x.st <- df[which(df[,1] == as.character(conn[i,1])),3]
x.end <- df[which(df[,1] == as.character(conn[i,2])),3]
y.st <- df[which(df[,1] == as.character(conn[i,1])),4]
y.end <- df[which(df[,1] == as.character(conn[i,2])),4]
slope <- (max(y.st, y.end) - min(y.st, y.end))/(max(x.st, x.end) - min(x.st, x.end))
y.diff <- y.end - y.st
x.diff <- x.end - x.st
x.st <-  x.st  - y.diff*offset[j] + 0.02*y.range*offset[j]
x.end <- x.end - y.diff*offset[j] + 0.02*y.range*offset[j]
y.st <-  y.st  + x.diff*offset[j] + 0.02*x.range*offset[j]
y.end <- y.end + x.diff*offset[j] + 0.02*x.range*offset[j]
tmp <- tmp %>%
add_segments(x = x.st, xend = x.end,
y = y.st, yend = y.end,
showlegend = FALSE, line = list(width = 1, color = "gray"))
}
}
tmp <- suppressWarnings(tmp %>% add_trace(x = df$xCord, y = df$yCord, type="scatter",  showlegend = TRUE,
text = df[,2], textfont = list(size = max(10, 70/x.range)),
marker = list(
color = 'white', # Set marker color to white for the background
size = max(11, 90/x.range),       # Adjust marker size to encompass the text
symbol = 'square' # Use a square symbol for a clear background
),
mode="text", color = I(df$color), fill = 'white', hoverinfo = "text",
text = paste("\nElement: ", df$element)))
tmp
} else {
str <- ChemmineR::smiles2sdf("CCC")[[1]]
out <- plot(str, verbose = FALSE)
out
}
})
# output$structure <- renderPlot({
#   height = "100%"
#   selected <- input$filtered_table_rows_selected
#   if (length(selected)) {
#     row <- filtered_data()[selected, ]
#     formula <- row$formula
#     smiles <- as.character(row$smiles)
#     str <- ChemmineR::smiles2sdf(smiles)[[1]]
#     ChemmineR::plotStruc(str)
#
#   } else {
#     plot(0,0)
#   }
# })
}
# Run the app
shinyApp(ui, server)
package.path <- "C:/Users/cbroeckl/Documents/GitHub/"
package.name <- "pubchem.bio"
package.dir <- paste0(package.path, package.name)
## push to CRAN
setwd(package.dir)
devtools::release(package.dir, check = FALSE)
